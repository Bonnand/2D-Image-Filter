clearvars;
close all;

% Define convolution kernel (several options provided)
% kernel = [1 1 1 ; 1 0 1 ; 1 1 1] * 1/8; % Blur filter
 kernel = [-1 0 1 ; -2 0 2 ; -1 0 1] * 1/8; % Sobel-Y
% kernel = [-1 -2 -1 ; 0 0 0 ; 1 2 1] * 1/8; % Sobel-X
% kernel = [0 -1 0 ; -1 4 -1 ; 0 -1 0] * 1/4; % Laplacian

% Load grayscale image data from binary file
[binary_data] = textread('Lena128x128g_8bits.dat', '%s');
decimal_values = bin2dec(binary_data);
original_image = uint8(reshape(decimal_values, [128, 128]))';

% Initialize output image to apply filter
filtered_image = zeros(size(original_image));

% Perform manual convolution
for i = 2:size(original_image, 1) - 1
    for j = 2:size(original_image, 2) - 1
        local_patch = double(original_image(i - 1:i + 1, j - 1:j + 1));
        conv_result = local_patch .* kernel;
        filtered_image(i, j) = sum(conv_result(:));
    end
end

% Load filtered image generated by VHDL
[vhdl_data] = textread('Lena128x128g_8bits_filtered.dat', '%s');
vhdl_decimal = bin2dec(vhdl_data);
vhdl_output_image = uint8(reshape(vhdl_decimal, [128, 128]))';

% Convert to uint8 for display purposes
filtered_image = uint8(abs(filtered_image));

% Calculate difference between MATLAB and VHDL results
difference_image = vhdl_output_image - filtered_image;

% Display images for comparison
figure;
% Increased figure size for larger display
set(gcf, 'Position', [200, 200, 4800, 1600]);
subplot(1, 4, 1), imshow(original_image, []); title('LENA');
subplot(1, 4, 2), imshow(filtered_image, []); title('MATLAB Result');
subplot(1, 4, 3), imshow(vhdl_output_image, []); title('VHDL Result');
subplot(1, 4, 4), imshow(difference_image, []); title('Difference');

